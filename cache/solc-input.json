{
  "language": "Solidity",
  "sources": {
    "contracts/Brain.sol": {
      "content": "// contracts/Brain.sol\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./CDP.sol\";\n\ncontract Brain is Ownable{\n    \n    uint256 public tokensAmount = 0;\n    uint256 public maxUcropPerCDPValue = 1000;\n    uint256 public maxUcropPerClient = 10000;\n    uint256 public lastEtherRateInfo = 111;\n\n    address payable public ucropTokenAddress;\n    \n    \n    \n    mapping(address=>uint256) public tokensPerClient; //учет количества токенов по каждому клиенту\n    mapping(address=>address) public CDPHolder;  //Это и все, что ниже дешевле хранить в токене?\n    mapping(address=>uint256) public CDPDeposit; //\n    mapping(address=>uint256) public CDPUcropGiven; //\n    //mapping(address=>uint32) public CDPEtherMinCost; // до сюда\n    \n    address[] public contracts; // index of created contracts\n    mapping(address=>uint256) public CDPindexIncontracts;\n    uint32 public aliveCDPsCount = 0;\n    \n    function setUcropTokenAddress(address payable _newUcropTokenAddress)\n    onlyOwner\n    public\n    {\n        ucropTokenAddress = _newUcropTokenAddress;\n    }\n    \n    modifier onlyToken()\n    {\n        require(ucropTokenAddress == msg.sender);\n        _;\n    }\n\n    function getContractCount() // useful to know the row count in contracts index\n        public\n        view\n        returns(uint)\n    {\n        return aliveCDPsCount;\n    }\n    \n    modifier isLimit(uint256 _amountToGet) {\n        require(_amountToGet <= maxUcropPerCDPValue && _amountToGet > 0, \"Желаемое количество превышает максимально возможное для одного CDP\");\n        require(tokensPerClient[msg.sender] + _amountToGet <= maxUcropPerClient, \"Желаемое количество превышает максимально возможное для одного клиента\");\n        _;\n    }\n\n    function createNewCDP(uint256 _depositedEther, address _clientAddress, uint256 _givenTokens) //deploy a new contract\n        //isLimit(_amountToGet)\n        public\n        onlyToken()\n        returns(address newCDP)\n    {\n        CDP c = new CDP(_depositedEther, lastEtherRateInfo, _clientAddress, _givenTokens);\n        contracts.push(address(c));\n        CDPindexIncontracts[address(c)] = contracts.length - 1;\n        aliveCDPsCount++;\n        CDPHolder[address(c)] = _clientAddress;\n        CDPDeposit[address(c)] = _depositedEther;\n        CDPUcropGiven[address(c)] = _givenTokens;\n        //CDPEtherMinCost[c] = 75;\n        //c.transferOwnership(_clientAddress);\n        tokensAmount = tokensAmount + _givenTokens;\n        return address(c);\n    }\n    \n    modifier CDPUcropGivenCheck(address _CDP, uint _value)\n    {\n        require(CDPUcropGiven[_CDP]==_value, \"вы должны полностью вернуть то же количество токенов, сколько взяли у данного CDP\");\n        _;\n    }\n    \n     modifier CDPHolderCheck(address _CDP, address _client)\n    {\n            require(CDPHolder[_CDP]==address(0) || CDPHolder[_CDP]==_client, \"только владелец CDP может закрыть CDP\");\n            _;\n    }\n    \n    function startKillingCDP(address _CDP, uint _value, address _client)\n    onlyToken()\n    CDPUcropGivenCheck(_CDP, _value)\n    CDPHolderCheck(_CDP, _client)\n    view\n    public\n    returns (bool successStartKilling)\n    {\n        return true;\n    }\n    \n    function deleteAllCDPInfo(address _CDP) \n    onlyToken()\n    public\n    returns (uint DepositValue)\n    {\n        delete CDPUcropGiven[_CDP];\n        delete CDPHolder[_CDP];\n        DepositValue = CDPDeposit[_CDP];\n        delete CDPDeposit[_CDP];\n        uint256 index = CDPindexIncontracts[_CDP];\n        contracts[index] = address(0);\n        //delete contracts[index]; //TODO: корректное удаление индексов и логику просомтра CDP для клиентов\n        CDP cdp = CDP(_CDP);\n        cdp.killCDP();\n        aliveCDPsCount--;\n        return DepositValue;\n    }\n    \n    //информация о курсе валюты\n    function broadcastRate(uint _1EtherCost, uint32 _UcropEtherRatio)\n        public\n        onlyOwner\n    {\n        for(uint i=0; i < contracts.length; i++)\n        {\n            if(contracts[i]!=address(0))\n            {\n                CDP existingCDP = CDP(contracts[i]); //обращаемся к каждому адресу существующих CDP\n                existingCDP.getRateInfo(_1EtherCost); //сообщаем им информацию о курсе эфира\n                if(_1EtherCost<75)\n                {\n                    CDPHolder[contracts[i]]=address(0);\n                }\n            }\n        }\n        lastEtherRateInfo = _1EtherCost;\n        \n        UcropToken workingToken = UcropToken(ucropTokenAddress);\n        workingToken.setRate(_UcropEtherRatio);  //сообщаем токену информацию о курсе Укропа к Эфиру\n    }\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/CDP.sol": {
      "content": "// contracts/CDP.sol\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n//import \"@openzeppelin/contracts/\n\nimport \"./UcropToken.sol\";\n\ncontract CDP is Ownable {\n    \n    uint256 public EtherDeposited; //количество заблокированного эфира, на этом CDP\n    uint256 public lastRateInfo; //последняя полученная информация о курсе Эфира\n    uint256 public UcropGiven;\n    address public clientAddress; //адрес покупателя токенов\n    bool public canBeClosedOnlyByClient = true; //флаг, что CDP может быть закрыт только покупателем токенов\n    uint256 tokenAmount;\n    address tokenAddress;//когда токен будет задеплоен, станет доступен\n\n    constructor (uint256 _EtherDeposited, uint256 _lastRateInfo, address _clientAddress, uint _UcropGiven) public {\n        EtherDeposited = _EtherDeposited;\n        lastRateInfo = _lastRateInfo;\n        clientAddress = _clientAddress;\n        //tokenAmount = calcTokenAmount(_lastRateInfo);\n        UcropGiven = _UcropGiven;\n    }\n    \n    function getRateInfo(uint _1EtherCost) \n        external\n        onlyOwner()\n    {\n        lastRateInfo = _1EtherCost;\n        \n        //в случае, если курс Эфира ниже допустимого минимума\n        if(lastRateInfo < 75)\n        {\n            toAuctionOff();\n        }\n    }\n\n    //выставление содержимого CDP на открытый аукцион\n    function toAuctionOff()\n        private\n    {\n        canBeClosedOnlyByClient = false;\n    }\n    \n    function killCDP() \n    public\n    onlyOwner()\n    {\n        renounceOwnership();\n        //address payable theOwner;\n        //theOwner = owner();\n        //selfdestruct(theOwner);\n    }\n}\n"
    },
    "contracts/UcropToken.sol": {
      "content": "// contracts/UcropToken.sol\n//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./Brain.sol\";\nimport \"./CDP.sol\";\n\ncontract UcropToken is Ownable {\n    \n    string public constant name = \"Ucrop token\";\n    string public constant symbol = \"ucr\";\n    uint32 constant public decimals = 18;\n    uint32 public rate = 2; \n    uint256 public totalSupply ;\n    address public BrainAddress;\n    mapping(address=>uint256) public balances;\n    mapping (address => mapping(address => uint)) allowed;\n    \n  function mint(address  _to, uint _value, uint _depositedEther) internal {\n    assert(totalSupply + _value >= totalSupply && balances[_to] + _value >= balances[_to]);\n    balances[_to] += _value;\n    totalSupply += _value;\n    \n    Brain b = Brain(BrainAddress);\n    b.createNewCDP(_depositedEther, _to, _value);  //вызов функции создания CDP в Brain\n  }\n\n  function balanceOf(address _owner) public view returns (uint balance) {\n    return balances[_owner];\n  }\n\n  function transfer(address _to, uint _value) public returns (bool success) {\n      if(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) \n      {\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n      }\n      return false;\n    }\n  \n  function StartClosingCDP(address _CDP, uint _value) \n  public\n  {\n      require(balances[msg.sender] >= _value /* && balances[address(this)] + _value >= balances[address(this)]*/, \"Баланс даного клиента меньше\");\n      Brain b = Brain(BrainAddress);\n      b.startKillingCDP(_CDP, _value, msg.sender);\n      balances[msg.sender] -= _value;\n      balances[address(this)] += _value;\n      Transfer(msg.sender, address(this), _value);\n      \n      uint EtherDeposit = b.deleteAllCDPInfo(_CDP);\n      msg.sender.transfer(EtherDeposit);\n      //totalSupply = totalSupply - _value;\n  }\n\n  function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n    if( allowed[_from][msg.sender] >= _value &&\n    balances[_from] >= _value\n    && balances[_to] + _value >= balances[_to]) {\n      allowed[_from][msg.sender] -= _value;\n      balances[_from] -= _value;\n      balances[_to] += _value;\n      Transfer(_from, _to, _value);\n      return true;\n    }\n    return false;\n  }\n\n  function approve(address _spender, uint _value) public returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) public view returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n\n  event Transfer(address indexed _from, address indexed _to, uint _value);\n\n  event Approval(address indexed _owner, address indexed _spender, uint _value);\n\n  function getTokenAmount(uint256 _value) internal view returns (uint256) {\n    return _value / rate;\n  }\n\n  function setRate(uint32 _value) public\n  onlyBrain\n  {\n      rate = _value;\n  }\n  \n  function getRate() public view returns (uint32) {\n      return rate;\n  }\n\n  modifier onlyBrain()\n  {\n      require(msg.sender == BrainAddress, \"только Brain может устанавливать rate\");\n      _;\n  }\n\n  function setBrainAddress(address _newBrainAddress)\n  public\n  onlyOwner\n  {\n      BrainAddress = _newBrainAddress;\n  }\n\n\n  receive() external payable {\n    uint256 weiAmount = msg.value;\n    uint256 tokens = getTokenAmount(weiAmount);\n    mint(msg.sender, tokens, weiAmount);\n  }\n\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}